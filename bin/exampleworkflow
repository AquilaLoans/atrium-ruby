#!/usr/bin/env ruby
require "atrium"

$counter = 0

def checkJobStatus(userGUID, memberGUID)
  puts "\n2 second delay..."
  sleep(2)

  member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID
  memberResponse = member.aggregation_status
  status = memberResponse.status

  puts "\nJOB STATUS: " + status
  case status
  when "COMPLETED"
    readAggregationData(userGUID, memberGUID)
  when "HALTED", "FAILED"
    currentTime = Time.now.utc.iso8601().chomp('Z') + "+00:00"

    member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID
    lastSuccessTime = member.aggregation_status

    # Check if last successful aggregation over 3 days aggregation
    if (lastSuccessTime != nil && ((currentTime[8,2] - lastSuccessTime[8,2]).abs > 3 || (currentTime[5,2] - lastSuccessTime[5,2]).abs > 0 || (currentTime[0,4] - lastSuccessTime[0,4]).abs > 0))
      puts "\nClient should contact MX Support to resolve issue."
    else
      puts "\nAn update is currently unavailable. Please try again tomorrow"
    end
  when "CREATED", "UPDATED", "RESUMED", "CONNECTED", "DEGRADED", "DELAYED", "INITIATED", "REQUESTED", "AUTHENTICATED", "RECEIVED", "TRANSFERRED"
    checkJobStatus(userGUID, memberGUID)
  when "PREVENTED", "DENIED", "IMPAIRED"
    member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID
    institutionCode = member.institution_code

    puts "\nPlease update credentials"
    credentials = ::Atrium::Institution.credentials institutionCode
    updatedCredentials = []
    for credential in credentials
      puts "\nPlease enter in " + credential.label + ":"
      response = gets.chomp()
      credPair = {}
      credPair[:guid] = credential.guid
      credPair[:value] = response
      updatedCredentials.push(credPair)
    end

    member.update({credentials: updatedCredentials})

    checkJobStatus(userGUID, memberGUID)
  when "CHALLENGED"
    member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID
    puts "\nPlease answer the following challenges:"
    challenges = member.challenges
    challengeArray = []
    for challenge in challenges
      puts challenge.label
      answer = gets.chomp()
      credPair = {}
      credPair[:guid] = challenge.guid
      credPair[:value] = answer
      challengeArray.push(credPair)
    end

    member.resume challengeArray

    checkJobStatus(userGUID, memberGUID)
  when "REJECTED"
    member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID
    member.aggregate

    checkJobStatus(userGUID, memberGUID)
  when "EXPIRED"
    puts "\nUser did not answer MFA in time. Please try again tomorrow."
  when "LOCKED"
    puts "\nUser's account is locked at FI"
  when "IMPEDED"
    puts "\nUser's attention is required at FI website in order for aggregation to complete"
  when "DISCONTINUED"
    puts "\nConnection to institution is no longer available."
  when "CLOSED", "DISABLED"
    puts "\nAggregation is purposely turned off for this user."
  when "TERMINATED", "ABORTED", "STOPPED", "THROTTLED", "SUSPENDED", "ERRORED"
    if counter > 3
      counter = counter + 1
      checkJobStatus(userGUID, memberGUID)
    else
      puts "\nAn update is currently unavailable. Please try again tomorrow and contact support if unsuccessful after 3 days."
      counter = 0
    end
  else
    puts status
  end
end

def readAggregationData(userGUID, memberGUID)
  member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID

  puts "\n* Listing All Member Accounts and Transactions *"
  accounts = member.accounts
  for account in accounts
    puts "\nType: " + account.type + "\tName: " + account.name + "\tAvailable Balance: " + account.available_balance.to_s + "\tAvailable Credit: " + account.available_credit.to_s
    puts "Transactions"
    params = {:user_guid => member.user_guid, :guid => account.guid}
    transactions = account.transactions
    for transaction in transactions
      puts "\tDate: " + transaction.date + "\tDescription: " + transaction.description + "\tAmount: " + transaction.amount.to_s
    end
  end
end



::Atrium.configure do |config|
  config.mx_client_id = "YOUR_MX_CLIENT_ID"
  config.mx_api_key = "YOUR_MX_API_KEY"
end

userGUID = ""
memberGUID = ""
endUserPresent = ""

puts "Please enter in user GUID. If not yet created just press enter key: "
userGUID = gets.chomp()

puts "\nPlease enter in member GUID. If not yet created just press enter key: "
memberGUID = gets.chomp()

puts "\nPlease enter in if end user is present (true or false): "
endUserPresent = gets.chomp()


if userGUID == "" && memberGUID != ""
  puts "\nMust include user GUID when member GUID is entered."
  exit
end

if userGUID == "" && endUserPresent == "true"
  puts "\n* Creating user *"

  puts "\nPlease enter in an unique id: "
  identifier = gets.chomp()

  user = ::Atrium::User.create identifier: identifier, is_disabled: nil, metadata: nil
  userGUID = user.guid
  puts "\nCreated user: " + userGUID
end

if memberGUID != "" && endUserPresent == "true"
  member = ::Atrium::Member.read user_guid: userGUID, member_guid: memberGUID
  member.aggregate
  checkJobStatus(userGUID, memberGUID)
elsif memberGUID != ""
  readAggregationData(userGUID, memberGUID)
elsif endUserPresent == "true"
  puts "\n* Creating member *"

  institutions = ::Atrium::Institution.list
  for institution in institutions
    puts institution.name + " : institution code = " + institution.code
  end

  puts "\nPlease enter in desired institution code: "
  institutionCode = gets.chomp()

  credentials = ::Atrium::Institution.credentials institutionCode
  credentialArray = []
  for credential in credentials
    puts "\nPlease enter in " + credential.label + ":"
    response = gets.chomp()
    credPair = {}
    credPair[:guid] = credential.guid
    credPair[:value] = response
    credentialArray.push(credPair)
  end

  member = ::Atrium::Member.create user_guid: userGUID, institution_code: institutionCode, credentials: credentialArray
  memberGUID = member.guid
  puts "\nCreated member: " + memberGUID

  checkJobStatus(userGUID, memberGUID)
else
  puts "\nEnd user must be present to create a new member"
  exit
end

puts "\n* Deleting test user *"
user = ::Atrium::User.read guid: userGUID
user.delete
puts "Deleted user: " + user.guid
